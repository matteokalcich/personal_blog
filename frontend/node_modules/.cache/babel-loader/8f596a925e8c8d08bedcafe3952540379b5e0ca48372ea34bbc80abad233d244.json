{"ast":null,"code":"// The best filesystem for promises and array manipulation\nimport run from \"atocha\";\nimport fs from \"node:fs\";\nimport fsp from \"node:fs/promises\";\nimport { homedir, tmpdir } from \"node:os\";\nimport path from \"node:path\";\nimport { Readable } from \"node:stream\";\nimport swear from \"swear\";\n\n// Find whether it's Linux or Mac, where we can use `find`\nconst mac = () => process.platform === \"darwin\";\nconst linux = () => process.platform === \"linux\";\n\n// Retrieve the full, absolute path for the path\nconst abs = swear(async (name = \".\", base = process.cwd()) => {\n  name = await name;\n  base = await base;\n\n  // Absolute paths do not need more absolutism\n  if (path.isAbsolute(name)) return name;\n  if (name.slice(0, 2) === \"~/\") {\n    base = await home();\n    name = name.slice(2);\n  }\n\n  // We are off-base here; recover the viable base option\n  if (!base || typeof base !== \"string\") {\n    base = process.cwd();\n  }\n\n  // Return the file/folder within the base\n  return join(base, name);\n});\nconst copy = swear(async (src, dst) => {\n  src = await abs(src);\n  dst = await abs(dst);\n  await mkdir(dir(dst));\n  await fsp.copyFile(src, dst);\n  return dst;\n});\n\n// Get the directory from path\nconst dir = swear(async (name = \".\") => {\n  name = await abs(name);\n  return path.dirname(name);\n});\n\n// Check whether a filename exists or not\nconst exists = swear(async name => {\n  name = await abs(name);\n  return fsp.access(name).then(() => true, () => false);\n});\n\n// Get the home directory: https://stackoverflow.com/a/9081436/938236\nconst home = swear((...args) => join(homedir(), ...args).then(mkdir));\n\n// Put several path segments together\nconst join = swear((...parts) => abs(path.join(...parts)));\n\n// List all the files in the folder\nconst list = swear(async dir => {\n  dir = await abs(dir);\n  return swear(fsp.readdir(dir)).map(file => abs(file, dir));\n});\n\n// Create a new directory in the specified path\n// Note: `recursive` flag on Node.js is ONLY for Mac and Windows (not Linux), so\n// it's totally worthless for us\nconst mkdir = swear(async name => {\n  name = await abs(name);\n\n  // Create a recursive list of paths to create, from the highest to the lowest\n  const list = name.split(path.sep).map((part, i, all) => all.slice(0, i + 1).join(path.sep)).filter(Boolean);\n\n  // Build each nested path sequentially\n  for (let path of list) {\n    if (await exists(path)) continue;\n    await fsp.mkdir(path).catch(() => null);\n  }\n  return name;\n});\nconst move = swear(async (src, dst) => {\n  try {\n    src = await abs(src);\n    dst = await abs(dst);\n    await mkdir(dir(dst));\n    await fsp.rename(src, dst);\n    return dst;\n  } catch (error) {\n    // Some OS/environments don't allow move, so copy it first\n    // and then remove the original\n    if (error.code === \"EXDEV\") {\n      await copy(src, dst);\n      await remove(src);\n      return dst;\n    } else {\n      throw error;\n    }\n  }\n});\n\n// Get the path's filename\nconst name = swear(file => path.basename(file));\n\n// Read the contents of a single file\nconst read = swear(async (name, options = {}) => {\n  name = await abs(name);\n  const type = options && options.type ? options.type : \"text\";\n  if (type === \"text\") {\n    return fsp.readFile(name, \"utf-8\").catch(() => null);\n  }\n  if (type === \"json\") {\n    return read(name).then(JSON.parse);\n  }\n  if (type === \"raw\" || type === \"buffer\") {\n    return fsp.readFile(name).catch(() => null);\n  }\n  if (type === \"stream\" || type === \"web\" || type === \"webStream\") {\n    const file = await fsp.open(name);\n    return file.readableWebStream();\n  }\n  if (type === \"node\" || type === \"nodeStream\") {\n    return fs.createReadStream(name);\n  }\n});\n\n// Delete a file or directory (recursively)\nconst remove = swear(async name => {\n  name = await abs(name);\n  if (name === \"/\") throw new Error(\"Cannot remove the root folder `/`\");\n  if (!(await exists(name))) return name;\n  if (await stat(name).isDirectory()) {\n    // Remove all content recursively\n    await list(name).map(remove);\n    await fsp.rmdir(name).catch(() => null);\n  } else {\n    await fsp.unlink(name).catch(() => null);\n  }\n  return name;\n});\nconst sep = path.sep;\n\n// Get some interesting info from the path\nconst stat = swear(async name => {\n  name = await abs(name);\n  return fsp.lstat(name).catch(() => null);\n});\n\n// Get a temporary folder\nconst tmp = swear(async (...args) => {\n  const path = await join(tmpdir(), ...args);\n  return mkdir(path);\n});\n\n// Perform a recursive walk\nconst rWalk = name => {\n  const file = abs(name);\n  const deeper = async file => {\n    if (await stat(file).isDirectory()) {\n      return rWalk(file);\n    }\n    return [file];\n  };\n\n  // Note: list() already wraps the promise\n  return list(file).map(deeper).reduce((all, arr) => all.concat(arr), []);\n};\n\n// Attempt to make an OS walk, and fallback to the recursive one\nconst walk = swear(async name => {\n  name = await abs(name);\n  if (!(await exists(name))) return [];\n  if (linux() || mac()) {\n    try {\n      // Attempt to invoke run (command may fail for large directories)\n      return await run(`find ${name} -type f`).split(\"\\n\").filter(Boolean);\n    } catch (error) {\n      // Fall back to rWalk() below\n    }\n  }\n  return rWalk(name).filter(Boolean);\n});\n\n// Create a new file with the specified contents\nconst write = swear(async (name, body = \"\") => {\n  name = await abs(name);\n  // If it's a WebStream, convert it to a normal node stream\n  if (body && body.pipeTo) {\n    body = Readable.fromWeb(body);\n  }\n  if (body && typeof body !== \"string\" && !body.pipe && !(body instanceof Buffer)) {\n    body = JSON.stringify(body);\n  }\n  await mkdir(dir(name));\n  await fsp.writeFile(name, body, \"utf-8\");\n  return name;\n});\nconst files = {\n  abs,\n  copy,\n  dir,\n  exists,\n  home,\n  join,\n  list,\n  mkdir,\n  move,\n  name,\n  read,\n  remove,\n  rename: move,\n  sep,\n  stat,\n  swear,\n  tmp,\n  walk,\n  write\n};\nexport { abs, copy, dir, exists, home, join, list, mkdir, move, name, read, remove, move as rename, sep, stat, swear, tmp, walk, write };\nexport default files;","map":{"version":3,"names":["run","fs","fsp","homedir","tmpdir","path","Readable","swear","mac","process","platform","linux","abs","name","base","cwd","isAbsolute","slice","home","join","copy","src","dst","mkdir","dir","copyFile","dirname","exists","access","then","args","parts","list","readdir","map","file","split","sep","part","i","all","filter","Boolean","catch","move","rename","error","code","remove","basename","read","options","type","readFile","JSON","parse","open","readableWebStream","createReadStream","Error","stat","isDirectory","rmdir","unlink","lstat","tmp","rWalk","deeper","reduce","arr","concat","walk","write","body","pipeTo","fromWeb","pipe","Buffer","stringify","writeFile","files"],"sources":["/Users/matteo/Documents/personal_blog/frontend/node_modules/files/files.js"],"sourcesContent":["// The best filesystem for promises and array manipulation\nimport run from \"atocha\";\nimport fs from \"node:fs\";\nimport fsp from \"node:fs/promises\";\nimport { homedir, tmpdir } from \"node:os\";\nimport path from \"node:path\";\nimport { Readable } from \"node:stream\";\nimport swear from \"swear\";\n\n// Find whether it's Linux or Mac, where we can use `find`\nconst mac = () => process.platform === \"darwin\";\nconst linux = () => process.platform === \"linux\";\n\n// Retrieve the full, absolute path for the path\nconst abs = swear(async (name = \".\", base = process.cwd()) => {\n  name = await name;\n  base = await base;\n\n  // Absolute paths do not need more absolutism\n  if (path.isAbsolute(name)) return name;\n\n  if (name.slice(0, 2) === \"~/\") {\n    base = await home();\n    name = name.slice(2);\n  }\n\n  // We are off-base here; recover the viable base option\n  if (!base || typeof base !== \"string\") {\n    base = process.cwd();\n  }\n\n  // Return the file/folder within the base\n  return join(base, name);\n});\n\nconst copy = swear(async (src, dst) => {\n  src = await abs(src);\n  dst = await abs(dst);\n  await mkdir(dir(dst));\n  await fsp.copyFile(src, dst);\n  return dst;\n});\n\n// Get the directory from path\nconst dir = swear(async (name = \".\") => {\n  name = await abs(name);\n  return path.dirname(name);\n});\n\n// Check whether a filename exists or not\nconst exists = swear(async (name) => {\n  name = await abs(name);\n  return fsp.access(name).then(\n    () => true,\n    () => false\n  );\n});\n\n// Get the home directory: https://stackoverflow.com/a/9081436/938236\nconst home = swear((...args) => join(homedir(), ...args).then(mkdir));\n\n// Put several path segments together\nconst join = swear((...parts) => abs(path.join(...parts)));\n\n// List all the files in the folder\nconst list = swear(async (dir) => {\n  dir = await abs(dir);\n  return swear(fsp.readdir(dir)).map((file) => abs(file, dir));\n});\n\n// Create a new directory in the specified path\n// Note: `recursive` flag on Node.js is ONLY for Mac and Windows (not Linux), so\n// it's totally worthless for us\nconst mkdir = swear(async (name) => {\n  name = await abs(name);\n\n  // Create a recursive list of paths to create, from the highest to the lowest\n  const list = name\n    .split(path.sep)\n    .map((part, i, all) => all.slice(0, i + 1).join(path.sep))\n    .filter(Boolean);\n\n  // Build each nested path sequentially\n  for (let path of list) {\n    if (await exists(path)) continue;\n    await fsp.mkdir(path).catch(() => null);\n  }\n  return name;\n});\n\nconst move = swear(async (src, dst) => {\n  try {\n    src = await abs(src);\n    dst = await abs(dst);\n    await mkdir(dir(dst));\n    await fsp.rename(src, dst);\n    return dst;\n  } catch (error) {\n    // Some OS/environments don't allow move, so copy it first\n    // and then remove the original\n    if (error.code === \"EXDEV\") {\n      await copy(src, dst);\n      await remove(src);\n      return dst;\n    } else {\n      throw error;\n    }\n  }\n});\n\n// Get the path's filename\nconst name = swear((file) => path.basename(file));\n\n// Read the contents of a single file\nconst read = swear(async (name, options = {}) => {\n  name = await abs(name);\n  const type = options && options.type ? options.type : \"text\";\n  if (type === \"text\") {\n    return fsp.readFile(name, \"utf-8\").catch(() => null);\n  }\n  if (type === \"json\") {\n    return read(name).then(JSON.parse);\n  }\n  if (type === \"raw\" || type === \"buffer\") {\n    return fsp.readFile(name).catch(() => null);\n  }\n  if (type === \"stream\" || type === \"web\" || type === \"webStream\") {\n    const file = await fsp.open(name);\n    return file.readableWebStream();\n  }\n  if (type === \"node\" || type === \"nodeStream\") {\n    return fs.createReadStream(name);\n  }\n});\n\n// Delete a file or directory (recursively)\nconst remove = swear(async (name) => {\n  name = await abs(name);\n  if (name === \"/\") throw new Error(\"Cannot remove the root folder `/`\");\n  if (!(await exists(name))) return name;\n\n  if (await stat(name).isDirectory()) {\n    // Remove all content recursively\n    await list(name).map(remove);\n    await fsp.rmdir(name).catch(() => null);\n  } else {\n    await fsp.unlink(name).catch(() => null);\n  }\n  return name;\n});\n\nconst sep = path.sep;\n\n// Get some interesting info from the path\nconst stat = swear(async (name) => {\n  name = await abs(name);\n  return fsp.lstat(name).catch(() => null);\n});\n\n// Get a temporary folder\nconst tmp = swear(async (...args) => {\n  const path = await join(tmpdir(), ...args);\n  return mkdir(path);\n});\n\n// Perform a recursive walk\nconst rWalk = (name) => {\n  const file = abs(name);\n\n  const deeper = async (file) => {\n    if (await stat(file).isDirectory()) {\n      return rWalk(file);\n    }\n    return [file];\n  };\n\n  // Note: list() already wraps the promise\n  return list(file)\n    .map(deeper)\n    .reduce((all, arr) => all.concat(arr), []);\n};\n\n// Attempt to make an OS walk, and fallback to the recursive one\nconst walk = swear(async (name) => {\n  name = await abs(name);\n  if (!(await exists(name))) return [];\n  if (linux() || mac()) {\n    try {\n      // Attempt to invoke run (command may fail for large directories)\n      return await run(`find ${name} -type f`).split(\"\\n\").filter(Boolean);\n    } catch (error) {\n      // Fall back to rWalk() below\n    }\n  }\n  return rWalk(name).filter(Boolean);\n});\n\n// Create a new file with the specified contents\nconst write = swear(async (name, body = \"\") => {\n  name = await abs(name);\n  // If it's a WebStream, convert it to a normal node stream\n  if (body && body.pipeTo) {\n    body = Readable.fromWeb(body);\n  }\n  if (\n    body &&\n    typeof body !== \"string\" &&\n    !body.pipe &&\n    !(body instanceof Buffer)\n  ) {\n    body = JSON.stringify(body);\n  }\n  await mkdir(dir(name));\n  await fsp.writeFile(name, body, \"utf-8\");\n  return name;\n});\n\nconst files = {\n  abs,\n  copy,\n  dir,\n  exists,\n  home,\n  join,\n  list,\n  mkdir,\n  move,\n  name,\n  read,\n  remove,\n  rename: move,\n  sep,\n  stat,\n  swear,\n  tmp,\n  walk,\n  write,\n};\n\nexport {\n  abs,\n  copy,\n  dir,\n  exists,\n  home,\n  join,\n  list,\n  mkdir,\n  move,\n  name,\n  read,\n  remove,\n  move as rename,\n  sep,\n  stat,\n  swear,\n  tmp,\n  walk,\n  write,\n};\n\nexport default files;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}